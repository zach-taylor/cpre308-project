\section{Effectiveness}
\label{s:effectiveness} % This declares a label so you can reference the section elsewhere.

It is useful to analyze what impacts ASLR has on any given system. While ASLR has security benefits, it can have an impact on performance as well, so there are tradeoffs. In particular, itâ€™s important to analyze how effective ASLR is thwarting attacks, how it can be broken or weaken, and the overhead associated with it.

The basis for the security effectiveness of ASLR depends upon the chance of an attacker guessing the randomized locations. To decrease the likelihood of a successful attack, the search space for a guess must be increased. The search space increases when there are more bits of entropy in the random number generation. If n is the number of bits of entropy available, then $2^n$ represents the total number of possible addresses. This number increases very quickly as entropy increases. For a 32-bit system, the number of bits of entropy is 16-20 bits. This leaves a relatively small search space that could easily be brute forced in a small amount of time with modern computing. Realistic implementations, such as PaX, have methods of preventing brute forcing, however. With the adoption of 64-bit architectures, the number of entropy bits increased to around 48 bits, making brute force infeasible.

When implemented perfectly, ASLR is a sound defense. Unfortunately if the implementation or some supporting code has a vulnerability or bug, ASLR can be bypassed. As previously stated, brute force may be possible if the conditions are correct, however this relies on a relatively small address space. The goal to getting past ASLR would be to exploit a bug in which the code leaks the starting memory address of a randomized memory segment. One common way that the address of a pointer is leaked is through a format-string attack. \cite{bhatkar2003address} An attacker uses the printf function or one of its variants where a input string is placed directly in the format-string parameter. The attacker can then use the \%n or \%d identifiers to output a random address on the stack. Using this, the attacker can sometimes find out the location of the stack or heap and use a more traditional exploit such as a buffer overflow.

\begin{lstlisting}[caption=A dangerous printf statement]
printf(message);
\end{lstlisting}

An information disclosure like this is the main way to bypass ASLR. There are other ways, but they rely on very rare bugs.

Performance impacts differ based on the architecture and memory segment. On Linux, the performance hit can be as significant as 26\% for a 32-bit machine. \cite{payer2012too} The main cause for this is the requirement that executables must be compiled as position-independent in order to be compatible with ASLR. A position-independent executable is essentially a binary that is modified so that it can be run in any number of places in memory. This operation is very CPU register heavy and therefore causes significant performance losses for 32-bit architectures. On the other hand, since 64-bit architectures have more registers, ASLR has an almost negligible performance impact. It is interesting to note that the Windows implementation of ASLR suffers a negligible impact due to its method of randomization, which is at link-time rather than compile time.
